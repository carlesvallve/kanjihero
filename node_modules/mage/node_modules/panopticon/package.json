{
  "name": "panopticon",
  "version": "0.2.0",
  "description": "Data acquisition for applications that use the cluster module.",
  "contributors": [
    {
      "name": "Mark Stanley Everitt",
      "email": "meveritt@wizcorp.jp"
    },
    {
      "name": "Tom Farmer",
      "email": "tfarmer@wizcorp.jp"
    }
  ],
  "main": "index.js",
  "devDependencies": {
    "nodeunit": "0.8.x",
    "istanbul": "0.1.x",
    "jshint": "2.1.x"
  },
  "directories": {
    "test": "test"
  },
  "scripts": {
    "test": "nodeunit test",
    "cover": "istanbul cover nodeunit test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Wizcorp/panopticon"
  },
  "engines": {
    "node": ">=0.8"
  },
  "keywords": [
    "sampling",
    "cluster"
  ],
  "author": {
    "name": "Wizcorp, Inc.",
    "email": "info@wizcorp.jp"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "homepage": "http://documentup.com/Wizcorp/panopticon",
  "readme": "![Panopticon](https://raw.github.com/qubyte/panopticon/develop/icon.png)\n\n## Introduction\n\nPanopticon is a Node.js utility to aggregate samples generated by a Node.js application. It works in regular, single instance applications but shines in applications that make use of the `cluster` core module. Samples generated by all processes are sent to the master process and emitted so that the aggregated data may be used.\n\nPanopticon exposes a constructor. Instances live across the cluster, and expose a very simple API for a user to sample data. At regular intervals, the data acquired across the cluster is emitted by the master part of the instance.\n\nIn order to minimise parsing load due to interprocess communication, data is sub-aggregated on each worker/master for an interval, and then forwarded to the master for final aggregation, reducing the parsing load to a single object per machine per instance, rather than parsing a small object for every sample taken.\n\nPanopticon has no production dependencies! [Find it on npm](https://npmjs.org/package/panopticon).\n\n## Install\n\nPanopticon is 100% JavaScript with no production dependencies. Simply install with:\n\n```bash\nnpm install panopticon\n```\n\n## Usage\n\nRequire Panopticon like a regular node.js module:\n\n```javascript\nvar Panopticon = require('panopticon');\n```\n\nPanopticon itself is a constructor, so when you're ready to start it, make a new object\n\n```javascript\nvar panopticon = new Panopticon(startTime, name, interval, scaleFactor, persist, transformer);\n```\n\nwhere `startTime` (ms since the unix epoch) is an optional time to start from, `interval` is the time delay (in ms) between batches of data and `scaleFactor` scales the reporting from some of the reporter types. If no `startTime` is provided, then it defaults to `0`. Similarly, if no sane `interval` is provided, it defaults to 10 seconds. By default the scale of reporting is in kilohertz. `persist` is a boolean, and tells the panopticon if it should be keeping data paths around after each interval.\n\nThe `startTime`, if used, must be the same across your cluster. This is simple to manage using the optional environment  argument to `cluster.fork`. i.e. the master can use `startTime = Date.now()`, and pass this value to the forked workers with `cluster.fork({ START_TIME: startTime })`. If not used (undefined or otherwise falsy) then it defaults to 0, so the first interval will be short, but all workers will have the same starting point without communicating a value. A modulo function is used internally to calculate when the current interval ends, so there is no additional cost associated with starting from 0.\n\nIf no value is passed in for `scaleFactor`, it defaults to `1` (reports in kHz). Panopticon internally calculates the rate of increments, so it needs to be told if this scale is wrong. For example, to change the reporting of incrementers and timed samples to Hz, set this value to 1000. This only affects incrementers and timed samples, since these are concerned with timing. Sets and samples are your responsibility, so if these should be reporting in something other than kHz for those, then you must give the panopticon the data in the scale desired.\n\nBy default the PID of each worker and the master are logged, as well as the number of workers (not including the master). Everything else needs to be sent to the panopticon object using one of its acquisition methods. In each case the `id` is the identifier that should be associated with this piece of data, and path is an array of strings representing subkeys in descending order. The methods are\n\n - `panopticon.set(path, id, n)`, where `n`, a finite number, may replace a previous `n` for this `id`.\n - `panopticon.inc(path, id, n)`, where `n` is added to the previous value if `n` is a finite number. If `n` is not a finite number, then it defaults to `1`.\n - `panopticon.sample(path, id, n)`, which keeps track of the max, min, average and standard deviation of `n` over an interval.\n - `panopticon.timedSample(path, id, dt)`, which is like sample, but takes the output of a high resolution timer `dt` (or rather the difference between two timers). It also provides a count and total.\n\nWhen your application is shutting down, it should call `panopticon.stop()` to clear timers.\n\nOn the master, halfway between collections from the workers and itself the panopticon object emits aggregated data. This *only happens on the master*.\n\n```javascript\npanopticon.on('delivery', function (aggregatedData) {\n\t// Do something with aggregatedData\n});\n```\n\nThe delivered data is an object containing all of the data collected over the cluster.\n\n### `persist`\n\nWithout `persist` turned on, a completely fresh batch of data is started by each panopticon every interval. This means that loggers that get fired rarely are only represented in intervals in which they have occurred. Since this is not always desirable, `persist` tells a panopticon not to start from fresh, but simply to set the loggers to a null state. For `inc`s this is as simple as resetting to `0`, and for `set`s the value from the previous interval is kept. In the case of `sample` and `timedSample`, the subfields are set to `null` since no data recorded should be interpreted as a need for interpolation.\n\n### `transformer`\n\nA transformer function can be used to rearrange the aggregated data. For example:\n\n```javascript\nfunction transformer(data, id) {\n\tfunction checkValue(obj) {\n\t\tif (typeof obj !== 'object') {\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj.hasOwnProperty('value')) {\n\t\t\tobj.values = {};\n\t\t\tobj.values[id] = obj.value;\n\t\t\tdelete obj.value;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var key in obj) {\n\t\t\tif (obj.hasOwnProperty(key)) {\n\t\t\t\tcheckValue(obj[key]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcheckValue(data);\n\n\treturn data;\n}\n```\n\nThe function takes raw data, and looks for occurrences of the `'value'` key, associated with panopticon data types. When it finds one, it puts the content into a small object called `'values'` against a key which is the worker ID. Panopticon merges objects together on aggregation, so values objects are merged, keeping related data together.\n\n## Panoptica\n\nMultiple panoptica may be instantiated. The motivation for this is sampling over different intervals concurrently. Internally Panopticon keeps track of instances with IDs counting up from zero. To ensure consistency panoptica must be instantiated in the same order, meaning that you should avoid instantiating panoptica in separate asynchronous functions with indefinite execution order. Try to keep them in a synchronous group.\n\nIf a worker goes down, you may safely restart it. New panoptica instances catch up to the current interval and report to the master as normal.\n\nTo differentiate between different panoptica, each aggregated data has an `id` key, which is the same as the `id` of the panopticon responsible for it.\n\n## Points to note\n\nThe node.js implementation of setTimeout is buggy. The resulting timeout can ([and does](https://github.com/joyent/node/issues/5103)) fire early sometimes, contrary to expectations. This lead to some acrobatics to ensure that when it does fire early, it is reinitialised. This can be seen in `Panopticon.prototype.timeUp`.\n\nThe standard deviation method used by `panopticon.sample` is single pass. This leaves it more prone than a two pass algorithm to round off errors. A single pass method is used to avoid growing arrays whilst accumulating a batch. The specific algorithm used is the one found in *The Art of Computer Programming, Volume 2: Seminumerical Algorithms*, section 4.2.2.\n\n## Testing\n\nTests for Panopticon are written in nodeunit. To run them, execute the following command in the Panopticon directory:\n\n```bash\nnpm test\n```\n\nIf you want to inspect the test coverage, use the following:\n\n```bash\nnpm run-script cover\nopen coverage/lcov-report/index.html\n```\n\n(the last line assumes that you're on a mac)\n\n## Contributing\n\nContributions are welcome! Please observe the coding style of Panopticon. If you add functionality, then this *must* be accompanied by tests. If you break tests, you must have a good reason for doing so and provide updates to existing tests to fix the breakages. Please run JavaScript files changed in your branch through jshint to catch problems. A jshint config file is provided, and jshint is installed as a development dependency.\n\nPanopticon was something of an experiment in using node.js module architecture best practices. Throughout it uses the *module-constructor* pattern, a form of the substack pattern. Every JavaScript file exposes a constructor function on `module.exports`. Whatever your thoughts on this, please abide by the choices made for this module.\n\n# API\n\n## Class: `Panopticon`\n\nInstances are event emitters.\n\n### `Panopticon.registerMethod(name, loggerClass, validator)`\n\nThis class method allows the extension of Panopticon methods with a new logger class. This is used\ninternally by Panopticon, but it is also part of the public API. `loggerClass` receives the\narguments:\n\n - `val`: The initial data point to be logged.\n - `timeStamp`: A time stamp number.\n - `persistObj`: An optional event emitter. If it is not falsy, you should expect it to emit `'reset'` events with a time stamp.\n - `scaleFactor`: You may optionally ignore this value since it may not be relevant.\n - `interval`: The interval time over which a data point counts. You may ignore this if it is not relevant.\n\nInstances of the loggerClass must have the following methods:\n\n - `update(val, timeStamp)`: Add a new data point with a timeStamp.\n - `reset(timeStamp)`: Resets the state of the logger instance. If `persistObj` was given to the constructor then your constructor must register a listener on `persistObj` for the event `'reset'` that should call this method.\n - `toJSON`: This function should perform any final processing before serialization, and return an object.\n\nThe validator will receive single data points and should return true if they are valid, and false\nif not. Invalid points are simply ignored.\n\n### `Panopticon.getLoggerMethodNames()`\n\nReturns a copy of an array which lists registered method names.\n\n### `Panopticon.count()`\n\nReturns the number of panopticon instances that have been started. Useful for testing.\n\n### `Panopticon._reset()`\n\nResets the count of instances. Strictly for testing use only. Do not use this.\n\n### Event: 'delivery'\n\n```javascript\nfunction (data) { }\n```\n\nMaster only. A panopticon instance emits this event when it has a dataset object to deliver.\n\n### Event: 'sample'\n\n```javascript\nfunction(data, id) { }\n```\n\nMaster and workers. A panopticon instance emits this event when it has data to be\naggregated. This is a private event and should not be acted upon. Use the 'delivery' event.\n\n### Event: 'newInterval'\n\n```javascript\nfunction () { }\n```\n\nMaster and workers. A panopticon instance emits this event when a new interval begins. This is\nuseful for sets, which may be useful to do once per interval.\n\n### Event: 'reset'\n\n```javascript\nfunction () { }\n```\n\nMaster and workers. If the panopticon instance is persistent, then this event is emitted at the end\nof an interval, immediately before 'newInterval'.\n\n### Event: 'stopping'\n\n```javascript\nMaster and workers. Emitted when `panopticon.stop()` is called.\n```\n\n### `panopticon.sample(path, id, n)`\n\nThe sample method keeps track of the maximum, minimum and standard deviation of `n` over multiple\ncalls in an interval. The sample is registered to the aggregated object on the given `path` with a\nkey given by `id`.\n\n### `panopticon.timedSample(path, id, dt)`\n\nSimilar to the sample method, but instead of a number `n` it takes `dt`, the result of a [high\nresolution timer](http://nodejs.org/api/process.html#process_process_hrtime) call (a length 2\narray of numbers). This method also keeps track of the count and total time over all calls in an\ninterval.\n\n### `panopticon.inc(path, id, n)`\n\nIncrements by `n`. If this the first call of inc with this `path` and `id`, then the starting\nvalue is assumed to be 0.\n\n### `panopticon.set(path, id, value)`\n\nSet a value on a path with id.",
  "bugs": {
    "url": "https://github.com/Wizcorp/panopticon/issues"
  },
  "_id": "panopticon@0.2.0",
  "dist": {
    "shasum": "82a0d27845c215026cb56df055092f602ffde131"
  },
  "_from": "panopticon@0.2.0",
  "_resolved": "https://registry.npmjs.org/panopticon/-/panopticon-0.2.0.tgz"
}
